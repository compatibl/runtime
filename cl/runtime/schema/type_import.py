# Copyright (C) 2023-present The Project Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys
from importlib import import_module
from typing import List, Dict
from typing import Type
from cl.runtime.records.type_util import TypeUtil


class TypeImport:
    """Helper methods for Record."""

    _qual_name_dict: Dict[str, Type] = {}
    """Dictionary of classes with fully qualified name key in module.ClassName format."""

    _type_name_dict: Dict[str, Type] = {}
    """
    Dictionary of classes with unique key generated by TypeUtil.name(class_) method, 
    defaults to ClassName except when alias is defined to resolve a name collision.
    """

    @classmethod
    def get_qual_name(cls, class_: Type) -> str:
        """Get fully qualified name in module.ClassName format from the class."""
        return f"{class_.__module__}.{class_.__name__}"

    @classmethod
    def from_qual_name(cls, qual_name: str) -> Type:
        """Get class from fully qualified name in module.ClassName format."""

        # Return cached value if found
        if (result := cls._qual_name_dict.get(qual_name, None)) is not None:
            return result

        # Split fully qualified name into dot-delimited snake_case module and PascalCase class name
        module_name, class_name = qual_name.rsplit(".", 1)

        # Check that the module exists and is fully initialized
        module = sys.modules.get(module_name)
        module_spec = getattr(module, "__spec__", None) if module is not None else None
        module_initializing = getattr(module_spec, "_initializing", False) if module_spec is not None else None
        module_imported = module_initializing is False  # To ensure it is not another value evaluating to False

        # Import dynamically if not already imported, report error if not found
        if not module_imported:
            try:
                module = import_module(module_name)
            except ModuleNotFoundError:
                raise RuntimeError(f"Module {module_name} is not found when loading class {class_name}.")

        # Get class from module, report error if not found
        try:
            # Get class from module
            result = getattr(module, class_name)
            # Add to the qual_name and type_name dictionaries
            cls.add(result)
            return result
        except AttributeError:
            raise RuntimeError(f"Module {module_name} does not contain top-level class {class_name}.")

    @classmethod
    def from_type_name(cls, type_name: str) -> Type:
        """
        Get class by key generated by TypeUtil.name(class_) method, defaults to
        ClassName except when alias is defined to resolve a name collision.
        """

        # Return cached value if found
        if (result := cls._type_name_dict.get(type_name, None)) is not None:
            return result

    @classmethod
    def add(cls, class_: Type) -> None:
        """Add the specified class to the qual_name and type_name dicts without overwriting the existing values."""
        qual_name = cls.get_qual_name(class_)
        type_name = TypeUtil.name(class_)
        cls._qual_name_dict.setdefault(qual_name, class_)
        cls._type_name_dict.setdefault(type_name, class_)